## Tree
![Tree](https://user-images.githubusercontent.com/63636555/145666837-28ff700f-8a61-485b-90bd-c5ee1d6859b2.png)


## Heap
힙은 최댓값 및 최솟값을 찾아내는 연산을 빠르게 하기 위해 고안된 완전이진트리를 기반으로 한 자료구조다.
- parent is > children : MAX HEAP
- parent is < children : MIN HEAP
- 
![table](https://user-images.githubusercontent.com/63636555/145697648-a54a3eba-9670-4872-b537-809bd939ee97.png)

로그식의 값을 토대로, 트리에 요소가 몇 개 있는지 알면 트리의 높이를 계산할 수 있다.

## Add
![add](https://user-images.githubusercontent.com/63636555/145698009-41afa312-eb3c-4531-bd60-1fc383972265.png)

1. 비어있는 공간에 노드를 추가한다.
2. 부모 노드보다 큰 숫자인지 비교하고, 만약 그렇다면 두 노드를 바꾼다(trickle up)


## Remove
![remove](https://user-images.githubusercontent.com/63636555/145698045-9913c412-e709-49a1-a77b-e6491eeaf2f9.png)

1. 루트를 제거한다.
2. 트리의 마지막 요소를 루트에 넣는다.
3. 루트에 시작하여 두 자식 중 크기가 큰 노드와 바꿔주어 힙의 규칙을 만족하게 한다.(trickle down)

## TricleUp 함수
힙은 완전이진트리이기 때문에 노드의 위치는 다음과 같은 성질을 가진다.
children = 2 * parent + 1, 2 * parent + 2
parent = Math.floor((children - 1) / 2)

<pre><code>
int lastposition; // 어디까지 요소를 넣었는지 기록
E[] array = (E[]) new Object[size];
public void add(E obj){
	array[++lastposition] = obj; // 1. 노드 추가
	trickleup(lastposition); // 2. trickle up
}
public void swap(int from, int to){
	E tmp = array[from];
	array[from] = array[to];
	array[to] = tmp;
}
public void trickleup(int position){
	if (position == 0)
		return;
	int parent = (int) Math.floor((position-1)/2)
	if (((Comparable<E>) array[position]).compareTo(array.parent)>0) {
		swap(position, parent);
		trickleup(parent);
	}
}
</code></pre>


## Trickle down 함수
<pre><code>
public E remove(){
	E tmp = array[0];
	swap(0,lastposition--);
	trickleDown(0);
	return tmp;
}

public void trickleDown(int parent){
	int left = 2 * parent + 1;
	int right = 2 * parent + 2;
	//마지막 노드가 왼쪽 자식이고 이 값이 부모보다 클 때
	if(left == lastposition && (((Comparable<E>)array[parent])).compareTo(array[left]) < 0){
		swap(parent,left);
		return;
	}
	//마지막 노드가 오른쪽 자식이고 이 값이 부모보다 클 때
	if(right == lastposition && (((Comparable<E>)array[parent])).compareTo(array[right]) < 0){
		swap(parent,right);
		return;
	}
	/*마지막 노드가 요소의 총 개수에 해당하는 숫자와 같고 부모보다 작을 때. OR 마지막 노드가 요쇼의 총 개수에 해당하는 숫자보다 클 때.*/
	if(left >= lastposition || right >= lastposition)
		return;
	//마지막 노드가 아닐 때.
	if(array[left] > array[right] && array[parent] < array[left]){
		swap(parent,left);
		trickleDown(left);
	}
	else if(array[parent] < array[right]){
		swap(parent,right);
		trickleDown(right);
	}
}
</code></pre>

## Heap Sort
Max Heap에서 힙 규칙에 맞게 trickleDown을 반복하면 그 숫자들이 오름차순으로 정렬된다.<br>
이때 시간복잡도는 O(nlogn)이다. 모든 숫자들을 한번씩 탐색하는 n과 둘 중 큰 수를 고르는 logn을 곱한 값이다.
숫자들의 순서를 바꿔 정렬하기 때문에 데이터의 복사본을 만들 필요가 없다는 점이 힙 정렬의 장점이다.


## Tree
1. 완전 트리(Complete Tree)
![mceclip0](https://user-images.githubusercontent.com/63636555/145747061-63d84572-3f00-4ef0-a444-0b0c849462eb.png)

모든 잎이 아닌 노드가 2개의 자식 노드를 가지고 있고 마지막 줄은 왼쪽에서 오른쪽 순서로 채워져 있는 트리

2. 정 트리
![mceclip1](https://user-images.githubusercontent.com/63636555/145747078-0cc6a2f3-d213-483b-9ce5-45f33437414d.png)

모든 잎이 아닌 노드가 2개의 자식 노드를 가지고 있고 모든 잎이 같은 레벨에 있는 트리



## Tree : 순회(Traversal)
1. 전위 순회(pre order traversal)
 - visit root node
 - visit left node
 - visit right node
2. 중위 순회(in order traversal)
 - visit left node
 - visit root node
 - visit right node
3. 후위 순회(post order traversal)
 - visit left node
 - visit right node
 - visit root node
4. 너비 우선 선회/ 레벨 순서 순회(Breadth first traversal/ level order traversal)
 - 가장 위에 있는 노드에서 시작하여 왼쪽에서 오른쪽으로 가는 순회 방법.

## Tree : 표현
예 1
![mceclip0 (1)](https://user-images.githubusercontent.com/63636555/145925569-766d0c74-5bc7-4c0c-9e80-1f3ad4a01cf8.png)

중위 표기식 : 2* 3
후위 표기식 : 23*

예 2
![mceclip1 (1)](https://user-images.githubusercontent.com/63636555/145925605-b096112e-cd8c-449f-ad5a-b896040db7b6.png)

중위 표기식 : (22/11)+3)*(6+5)-50
후위 표기식 : 22 11 / 3 + 6 5 + * 50 -


## 노드 클래스
<pre><code>
class Node<E>{
	E data;
	Node<E> left, right;
	Node(E obj){
		this.data = obj;
		left = right = null;
	}
}
</code></pre>
