## 해시(Hash)
Linked List의 단점은 하나의 데이터를 찾기 위해서 모든 요소를 탐색해야하는 단점이 있다.<br>
이를 개선하기 위한 자료구조가 바로 Hash다.<br>
Hash는 Key와 Value값을 가지고 있기 때문에 원하는 key에 대한 value값을 바로 찾을 수 있다.

* 해시 함수를 작성할 때 다음과 같은 점들을 고려해야 한다.
1. 데이터의 속성
2. 연산이 빨라야 한다.
3. 두 요소가 같다면 같은 값을 반환해야 한다.
4. 같은 실행 환경일 경우 같은 객체라면 같은 값이 나와야 한다.
5. 코드를 새로 실행하면 객체가 같더라도 다른 값이 나올 수 있다.
6. 코드에서 최대한 충돌이 일어나지 않도록 해야한다.
6번과 7번이 발생하는 이유는 코드를 실행할 경우 hashcode는 메모리 주소를 기반으로 데이터를 처리하기 때문이다.

## Hash Collision
![hash collision](https://user-images.githubusercontent.com/63636555/145001405-65b5dd5a-c908-43fe-b6f0-b775fd8d49d0.png)

위의 그림처럼 서로 다른 value를 가진두 데이터의 key값이 일치하는 경우를 Hash Collision이라고 한다.


## 해시 함수에서의 문자열
해시 코드의 반환형은 Integer이기 때문에 문자를 유니코드로 변환하여 숫자로 나타낼 수 있다.

<pre><code>
public int hashCode(String s) {
	int g=31;
	int hash=0;
	// 문자열을 숫자로 나타내기
	// 상수 g를 문자의 위치만큼 제곱한 뒤 곱합니다.
	for (int i=s.length-1; i >= 0; i--)
		hash = g*hash + s.charAt(i);
	return hash;
}
</code></pre>

## 해시 크기 최적화
Hash Collision을 최소화하기 위해 Hash의 크기를 최적화한다.
ex 1) 해시의 크기를 홀수로 설정한다. % 연산자를 사용했을 때 다양한 결과가 나온다.
ex 2) 해시의 크기를 소수로 설정한다. 나머지가 다양한 숫자가 나온다.


## 양수로 변환
자바에서 int형은 8비트의 수로 나타내는데 첫번째 숫자가 0이면 양수, 1이면 음수다.<br>
해시테이블을 사용하기 위해 인덱스를 사용해야하는데 인덱스가 음수일 수 없으므로 2의 보수를 활용해 음수인 값을 양수로 변환해주어야 한다.
<pre><code>
int hashval = data.hashCode(s);
hasval = hashval & ox7FFFFFFF;
hasgval = hashval % tableSize;
</code></pre>


## Load Factor 메소드
Load Factor(적재율)은 해시에 데이터가 얼마만클 있는지를 알려주는 factor다. λ의 크기에 따라 데이터의 충돌을 방지하기 위해 해시의 크기를 조절한다.

## 해시 충돌을 해결하는 방법
1. Linear probing
 채우려는 공간이 이미 차 있다면, 비어있는 칸을 찾을 때까지 다음 칸을 확인하는 방법.
2. Quadratic probing
 다음 칸 대신 1부터 순서대로 제곱하여 더한 칸을 확인하는 방법. 인덱스의 크기가 테이블보다 커진다면 %연산을 통해 인덱스 값을 조절한다.
3. double hashing
 2개의 hasgCode함수를 활용한다. 첫번째 hashCode 적용시 이미 데이터가 존재한다면 두 번째 hashCode의 반환값을 더해 그 위치에 데이터를 넣는다.
