## 해시(Hash)
Linked List의 단점은 하나의 데이터를 찾기 위해서 모든 요소를 탐색해야하는 단점이 있다.<br>
이를 개선하기 위한 자료구조가 바로 Hash다.<br>
Hash는 Key와 Value값을 가지고 있기 때문에 원하는 key에 대한 value값을 바로 찾을 수 있다.

* 해시 함수를 작성할 때 다음과 같은 점들을 고려해야 한다.
1. 데이터의 속성
2. 연산이 빨라야 한다.
3. 두 요소가 같다면 같은 값을 반환해야 한다.
4. 같은 실행 환경일 경우 같은 객체라면 같은 값이 나와야 한다.
5. 코드를 새로 실행하면 객체가 같더라도 다른 값이 나올 수 있다.
6. 코드에서 최대한 충돌이 일어나지 않도록 해야한다.
6번과 7번이 발생하는 이유는 코드를 실행할 경우 hashcode는 메모리 주소를 기반으로 데이터를 처리하기 때문이다.

## Hash Collision
![hash collision](https://user-images.githubusercontent.com/63636555/145001405-65b5dd5a-c908-43fe-b6f0-b775fd8d49d0.png)

위의 그림처럼 서로 다른 value를 가진두 데이터의 key값이 일치하는 경우를 Hash Collision이라고 한다.


## 해시 함수에서의 문자열
해시 코드의 반환형은 Integer이기 때문에 문자를 유니코드로 변환하여 숫자로 나타낼 수 있다.

<pre><code>
public int hashCode(String s) {
	int g=31;
	int hash=0;
	// 문자열을 숫자로 나타내기
	// 상수 g를 문자의 위치만큼 제곱한 뒤 곱합니다.
	for (int i=s.length-1; i >= 0; i--)
		hash = g*hash + s.charAt(i);
	return hash;
}
</code></pre>

## 해시 크기 최적화
Hash Collision을 최소화하기 위해 Hash의 크기를 최적화한다.
ex 1) 해시의 크기를 홀수로 설정한다. % 연산자를 사용했을 때 다양한 결과가 나온다.
ex 2) 해시의 크기를 소수로 설정한다. 나머지가 다양한 숫자가 나온다.


## 양수로 변환
자바에서 int형은 8비트의 수로 나타내는데 첫번째 숫자가 0이면 양수, 1이면 음수다.<br>
해시테이블을 사용하기 위해 인덱스를 사용해야하는데 인덱스가 음수일 수 없으므로 2의 보수를 활용해 음수인 값을 양수로 변환해주어야 한다.
<pre><code>
int hashval = data.hashCode(s);
hasval = hashval & ox7FFFFFFF;
hasgval = hashval % tableSize;
</code></pre>


## Load Factor 메소드
Load Factor(적재율)은 해시에 데이터가 얼마만클 있는지를 알려주는 factor다. λ의 크기에 따라 데이터의 충돌을 방지하기 위해 해시의 크기를 조절한다.


## 해시 충돌을 해결하는 방법
1. Linear probing
 채우려는 공간이 이미 차 있다면, 비어있는 칸을 찾을 때까지 다음 칸을 확인하는 방법.
2. Quadratic probing
 다음 칸 대신 1부터 순서대로 제곱하여 더한 칸을 확인하는 방법. 인덱스의 크기가 테이블보다 커진다면 %연산을 통해 인덱스 값을 조절한다.
3. double hashing
 2개의 hasgCode함수를 활용한다. 첫번째 hashCode 적용시 이미 데이터가 존재한다면 두 번째 hashCode의 반환값을 더해 그 위치에 데이터를 넣는다.

## Chaining
![chaining](https://user-images.githubusercontent.com/63636555/145145112-ba779455-d4ca-4531-8f02-a7324407b2f4.png)

체이닝은 배열의 요소마다 Linked List를 만들어 수많은 데이터를 수용할 수 있게 하는 방법이다.<br>
체인 해시를 사용하면 λ(적재율)는 1 보다 클 수 있다.<br>
하지만 hashCode가 같은 숫자만 return하면 하나의 체인이 너무 길어지기 때문에 시간복잡도가 커지는 문제가 발생한다. 그렇기 때문에 적절한 hashCode를 작성하여 매번 다른 값을 return할 수 있도록 한다.


## Rehashing
체인 해시에서 해시가 너무 많이 차면 해시 테이블의 크기를 조정해야 한다.
크기가 2배인 배열은 생성한 뒤 다음과 같은 코드를 실행시킨다.
<pre><code>
//data의 index 결정
int idx = x.hashCode(s);
idx = idx & ox7FFFFFFF;
idx = idx % tableSize;
</code></pre>

위의 코드와 같이 위치를 옮기면 tableSize가 다르기 때문에 idx 값이 바뀌게 되어 원하는 위치를 찾을 수 없습니다.<br>
그렇기 때문에 데이터의 위치를 변경할 때, 각 요소들에 대해 newTableSize를 적용하여 hashCode를 적용해야합니다.
<pre><code>
//data의 index 결정
int idx = a.hashCode(s); // a는 첫번째 
idx = idx & ox7FFFFFFF;
idx = idx % newTableSize;
</code></pre>
