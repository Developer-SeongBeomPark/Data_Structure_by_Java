## 노드와 크기
<pre><code>
public class LinkedList<E> implements ListI<E>{
  //노드 정의
  class Node<E>{
    E data;
    Node<E> next;
    public Node(E obj){
      data = obj;
      next = null;
      }
   }
   
   private Node<E> head;
   private int currentSize;
   
   //Constructor
   public LinkedList(){
    head = null;
    currentSize = 0;
    }
}
</code></pre>

※ currentSize를 사용하는 이유 :<br>
 크기가 n인 연결 리스트의 사이즈를 알기 위해선 n만큼의 시간복잡도가 필요하다. 하지만 currentSize를 이용하여 새로운 노드가<br>
 추가될 때마다 1을 더하면 연결 리스트의 사이즈를 알기 위한 시간복잡도는 1이 된다.
 
 
 ## Boundary Conditions
 1. 자료구조가 비어있는 경우
 2. 자료구조에 단 하나의 요소만 들어있는 경우
 3. 자료구조의 첫 번째 요소를 제거하거나 추가하는 경우
 4. 자료구조의 마지막 요소를 제거하거나 추가하는 경우
 5. 자료구조의 중간 부분을 처리하는 경우
 
 
 ## addFirst 메소드
 1. 새로운 노드를 만든다
 2. 새로운 노드의 next가 첫번째 노드를 가르키게 만든다.
 3. head가 새로운 노드를 가르키게 한다.
 <pre><code>
 public void addFirst(E obj){
  Node<E> node = new Node<E><obj);
  node.next = head;
  head = node;
 }
 </code></pre>
 
 * Boundary Conditions를 고려해봐도 문제가 되는 경우가 없다.


## addLast 메소드
마지막 노드를 찾기 위해 tmp 노드를 생성하게 되면 시간복잡도가 O(N)이 걸린다. 이를 해결하기 위해<br>
마지막 노드를 가르키는 tail node를 생성한다. --> 시간복잡도 O(1).
<pre><code>
public void addLast(E obj){
  Node<E> node = new Node<E>(obj);
  if(head == null){
    head = tail = node;
    currentSize++;
    return;
  }
  tail.next = node;
  tail = node;
  currentSize++;
}
</code></pre>
